<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        function handleResult(error, result) {
            if (error) {
                console.error(error);
            }
            else {
                console.log("Результат деления:", result);
            }
        }

        function asyncDivision(number1, number2, callback) {
            console.log("Выполнение асинхронной операции");
            setTimeout(() => {
                if (number2 == 0) {
                    callback(new Error("Попытка деления на нуль: " + number1 + "/" + number2), null);
                }
                else {
                    callback(null, number1 / number2);
                }
            }, 2000);
        }

        asyncDivision(10, 2, handleResult);
        asyncDivision(10, 0, handleResult);

        /*
            Чрезмерное использование функций обратного вызова может привести к созданию структуры кода, 
            известной среди разработчиков JavaScript как callback hell (ад обратных вызовов). Такая структура
            кода возникает, когда колбэк в одной асинхронной функции вызывает другую асинхронную функцию, 
            колбэк которой, в свою очередь, может вызывать третью асинхронную функцию и так далее.
           
        fs.readdir(source, function (err, files) {
            if (err) {
                console.log('Error finding files: ' + err);
            } else {
                files.forEach(function (filename, fileIndex) {
                    console.log(filename);
                    gm(source + filename).size(function (err, values) {
                        if (err) {
                            console.log('Error identifying file size: ' + err);
                        } else {
                            console.log(filename + ' : ' + values);
                            var aspect = (values.width / values.height);
                            widths.forEach(function (width, widthIndex) {
                                var height = Math.round(width / aspect);
                                console.log('resizing ' + filename + 'to ' + height + 'x' + height);
                                this.resize(width, height).write(dest + 'w' + width + '_' + filename, function (err) {
                                    if (err) {
                                        console.log('Error writing file: ' + err);
                                    }
                                });
                            }.bind(this));
                        }
                    });
                });
            }
        });

        Для решения этой проблемы начиная со стандарта ES2015 в JavaScript была добавлена поддержка промисов.
        */
    </script>
</body>

</html>